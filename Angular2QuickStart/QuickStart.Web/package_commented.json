//json doesn't support comments. So this is converted using jsmin - http://www.crockford.com/javascript/jsmin.html
//jsmin <package_commented.json >package.json
{
  "name": "angular2-quickstart",
  "version": "1.0.0",
  "scripts": {
    "start": "tsc && concurrently \"npm run tsc:w\" \"npm run lite\" ",
    "lite": "lite-server",
    "postinstall": "typings install", //We installed the typings tool with npm (it's listed among the devDependencies in the package.json) and added an npm script to run that tool automatically after npm installation completes. We can run it manually by running 'npm run typings install'
    "tsc": "tsc",
    "tsc:w": "tsc -w",
    "typings": "typings"
  },
  "license": "ISC",
  "dependencies": {
    "@angular/common": "2.0.0-rc.5", //The commonly needed services, pipes and directives provided by the Angular team.
    "@angular/compiler": "2.0.0-rc.5", //Angular's Template Compiler. It understand templates and can convert them to code that makes the app run and render. Developers typically don’t interact with the compiler directly. They use it indirectly via platform-browser-dynamic or the offline template compiler.
    "@angular/core": "2.0.0-rc.5", //Critical runtime parts of the framework needed by every application. Includes all metadata decorators, Component, Directive, dependency injection, and the component lifecycle hooks.
    "@angular/forms": "0.3.0",
    "@angular/http": "2.0.0-rc.5", //Angular's http client.
    "@angular/platform-browser": "2.0.0-rc.5",
    "@angular/platform-browser-dynamic": "2.0.0-rc.5", //Everything DOM and browser related, especially the pieces that help render into DOM. This package also includes the bootstrapStatic method for bootstrapping applications for production builds that pre-compile templates offline.
    "@angular/router": "3.0.0-rc.1", //Component router.
    "@angular/router-deprecated": "2.0.0-rc.2",
    "@angular/upgrade": "2.0.0-rc.5", //Set of utilities for upgrading Angular 1 applications.
    "systemjs": "0.19.27", //A dynamic module loader compatible with the ES2015 module specification. There are other viable choices including the well-regarded webpack. SystemJS happens to be the one we use in the documentation samples. It works.
    "core-js": "^2.4.0", //Monkey patches the global context (window) with essential features of ES2015 (ES6). Developers may substitute an alternative polyfill that provides the same core APIs. This dependency should go away once these APIs are implemented by all supported ever-green browsers.
    "reflect-metadata": "^0.1.3", //A dependency shared between Angular and the TypeScript compiler. Developers should be able to update a TypeScript package without upgrading Angular, which is why this is a dependency of the application and not a dependency of Angular.
    "rxjs": "5.0.0-beta.6", //A polyfill for the Observables specification currently before the TC39 committee that determines standards for the JavaScript language. Developers should be able to pick a preferred version of rxjs (within a compatible version range) without waiting for Angular updates.
    "zone.js": "^0.6.12", //A polyfill for the Zone specification currently before the TC39 committee that determines standards for the JavaScript language. Developers should be able to pick a preferred version of zone.js to use (within a compatible version range) without waiting for Angular updates.
    "angular2-in-memory-web-api": "0.0.15", //An Angular-supported library that simulates a remote server's web api without requiring an actual server or real http calls. Good for demos, documentation samples, and early stage development (before we even have a server). Learn about it in the Http Client chapter.
    "bootstrap": "^3.3.6"
  },
  "devDependencies": {
    "concurrently": "^2.0.0",
    "lite-server": "^2.2.0",
    "typescript": "^1.8.10",
    "typings":"^1.0.4"
    /*
    Many JavaScript libraries such as jQuery, the Jasmine testing library, and Angular itself, extend the JavaScript environment with features and syntax that the TypeScript compiler doesn't recognize natively. When the compiler doesn't recognize something, it throws an error.
    We use TypeScript type definition files — d.ts files — to tell the compiler about the libraries we load.
    We need do nothing to get typings files for library packages which include d.ts files
    Sadly, many libraries — jQuery, Jasmine, and Lodash among them — do not include d.ts files in their npm packages. Fortunately, either their authors or community contributors have created separate d.ts files for these libraries and published them in well-known locations. The typings tool can find and fetch these files for us.
    */
  }
}
